# Project Research Summary

**Project:** generate-natal-chart v1.1 (Transits & Progressions)
**Domain:** Astrological software - predictive techniques (transits, secondary progressions, solar arc directions)
**Researched:** 2026-02-17
**Confidence:** HIGH

## Executive Summary

Extending the existing natal chart tool to include transits, secondary progressions, and solar arc directions is a natural evolution that requires zero new dependencies. Kerykeion 5.7.2 already provides native transit support via `TransitsTimeRangeFactory` and `EphemerisDataFactory`, while progressions and solar arc require simple manual calculations (day-for-a-year formula + arithmetic). The recommended approach is to extend the existing monolithic `astrology_calc.py` with ~700 LOC across new CLI modes (`--transits`, `--progressions`, `--solar-arc`) that load natal profiles and calculate predictive overlays.

The primary architectural strategy is fresh calculation with optional persistence: transits change constantly so calculate on-demand, progressions change slowly so calculate for target dates, both with optional snapshot saving. This preserves the existing natal chart workflow (which must not break) while adding time-based predictive layers. Key risks center on timezone confusion across multiple calculation dates (birth location vs query location vs current location), date range performance for timeline queries (must limit to 180 days max with intelligent ephemeris use), and the critical requirement to maintain natal chart functionality intact during integration.

Expert astrology software follows a tri-wheel pattern (natal inner, progressions middle, transits outer) with configurable orbs per calculation type (transits 1-3°, progressions 1°, solar arc 0.5-1°). The tool should prioritize current transit snapshots (auto-loaded with charts) and targeted progression queries (specific age/year) before attempting complex timeline features.

## Key Findings

### Recommended Stack

Kerykeion 5.7.2 provides everything needed with zero new dependencies. Research confirmed that Kerykeion's v5.x factory architecture includes native transit support via `TransitsTimeRangeFactory` for comparing natal charts against time-series ephemeris data generated by `EphemerisDataFactory`. Secondary progressions and solar arc directions are not natively supported but require trivial implementation: day-for-a-year date arithmetic plus reusing Kerykeion's `AstrologicalSubjectFactory` for progressions, and solar arc calculation via `swisseph.calc_ut()` for progressed Sun position plus arithmetic to apply the arc to all natal positions.

**Core technologies:**
- **Kerykeion 5.7.2** (no upgrade): Native transit support via `TransitsTimeRangeFactory`, factory architecture handles aspect detection, configurable orbs and active points
- **Python 3.11** (no change): Required for pyswisseph prebuilt wheels, already validated in v1.0
- **pyswisseph** (bundled with Kerykeion): Direct access via `swisseph.calc_ut()` for secondary progression and solar arc calculations

**What's built-in vs manual:**
- Transits: Fully supported via Kerykeion factories (production-ready)
- Secondary progressions: Manual calculation using day-for-a-year formula + existing `AstrologicalSubjectFactory`
- Solar arc: Manual calculation using arc arithmetic + `swisseph.calc_ut()` for progressed Sun

No additional libraries (immanuel-python, flatlib, etc.) provide value — they add dependency overhead without Kerykeion-compatible data models.

### Expected Features

Research into established astrology software (TimePassages, Astro-Seek, Astro Gold) reveals clear feature expectations:

**Must have (table stakes):**
- Current transit snapshot (auto-calculated when loading chart profiles)
- Transit-to-natal aspects with major aspects (conjunction, opposition, trine, square, sextile)
- Secondary progressions for target date/age with day-for-a-year calculation
- Progressed-to-natal aspects with 1° orb standard
- Solar arc directions for target year with true arc method
- Solar arc-to-natal aspects with 0.5-1° orb (tighter than progressions)
- Configurable orbs per calculation type
- House positions for transits/progressions (using natal birth location)
- Retrograde status flags for all chart types
- Interpretation guide for predictive work (like existing natal guide)

**Should have (competitive):**
- Transit timeline with preset ranges (week/month/3mo/year)
- Progressed Moon monthly precision (moves 12-14°/year, changes sign every ~2.5 months)
- Applying vs separating aspect indicators
- Aspect grid terminal display (clean tabular output)
- Fresh vs snapshot modes (calculate fresh or optionally save snapshots)

**Defer (v2+):**
- Solar/lunar returns (different chart type, location-dependent, adds complexity)
- Synastry/composite charts (two-chart comparison, different interpretation context)
- Transit alerts/notifications (requires infrastructure beyond CLI scope)
- Minor aspects for transits (low signal-to-noise, not standard practice)
- Multiple house systems (Kerykeion limitation, config complexity)

### Architecture Approach

Extend the existing three-tier architecture (Skill layer → Python backend → Storage) without breaking natal chart functionality. The Python backend grows from 1,070 LOC to ~1,770 LOC (stays monolithic for v1.1, consider splitting if synastry added in v2 pushes to 3,000+ LOC).

**Major components:**
1. **New CLI modes in `main()`** — Add argument groups for `--transits`, `--progressions`, `--solar-arc` with exclusive routing logic, reuse existing natal argument parsing patterns
2. **Cross-chart aspect calculation** — Generic `calculate_aspects_between_charts()` function handles transits, progressions, solar arc, and future synastry with configurable orbs
3. **Fresh calculation with optional persistence** — Calculate predictive data on-demand (print to stdout), optionally save snapshots with `--save` flag to `~/.natal-charts/{slug}/transits-YYYY-MM-DD.json` (date-specific), `progressions-YYYY.json` (year-specific), `solar-arc-YYYY.json`
4. **Skill layer context injection** — Dual interpretation guides (natal guide + transit guide) injected when predictive data present, combined JSON output for natal + transits/progressions
5. **Timezone handling strategy** — Track three separate timezone contexts: `birth_tz_str` (birth location), `query_tz_str` (transit query timezone, defaults to birth location), `user_current_tz` (only for `--now` transits), always convert to UTC before Kerykeion

**Key patterns:**
- **Pattern 1:** Fresh calculation with optional persistence (no stale snapshots, simple storage model)
- **Pattern 2:** Cross-chart aspect calculation (single implementation for all predictive techniques)
- **Pattern 3:** Monolithic extension (keep single file until ~2,000 LOC, then split only if needed)

**Integration points:**
- Reuse existing: `position_to_sign_degree()`, `valid_date()`, `valid_time()`, `get_planet_dignities()`, element/modality distribution logic
- Modify: `main()` for new argument groups
- Add: `load_natal_profile()`, `build_transit_json()`, `build_progression_json()`, `build_solar_arc_json()`, `calculate_aspects_between_charts()`, `find_transit_events()`

### Critical Pitfalls

1. **Breaking existing natal chart functionality** — Adding shared code paths (timezone conversion, Kerykeion initialization, JSON assembly) risks introducing regressions. Prevention: Isolate transit/progression logic in separate functions, never modify existing natal chart code paths, create regression test suite before integration.

2. **Timezone confusion across multiple dates** — Natal uses birth timezone, transits need query timezone, progressions use birth timezone for both dates. Mixing these produces incorrect positions by hours. Prevention: Track three explicit timezone contexts (`birth_tz_str`, `query_tz_str`, `user_current_tz`), always convert to UTC before Kerykeion, never mix timezone-aware and naive datetime objects.

3. **Date range performance explosion** — Naive loops creating full charts for 365+ dates takes 10+ seconds. Prevention: Use Kerykeion's `TransitsTimeRangeFactory` for date ranges, limit timeline queries to 180 days max with clear error, skip house calculations for transits unless requested, use `active_points` parameter to limit calculations.

4. **Ephemeris accuracy limits for historical/future dates** — Swiss Ephemeris degrades outside practical range (1900-2100 is reliable). Prevention: Define supported ranges explicitly (birth dates 1800-present, transit queries 1900-2100, progressions birth+120 years max), return clear error messages for out-of-range dates.

5. **Secondary progressions retrograde station math errors** — Planets stationing retrograde/direct in first 80 days of life complicate day-for-a-year calculation. Prevention: Use Kerykeion's progression calculations directly (handles retrograde internally), don't implement day-for-a-year math manually, include retrograde status in progressed planet output.

6. **Solar arc true vs mean arc confusion** — True arc (actual Sun progression) vs mean arc (0.9856°/year average) produces ~1° difference after 90 years. Prevention: Use true solar arc by default (`progressed_sun_longitude - natal_sun_longitude`), add `--solar-arc-method {true|mean}` flag for compatibility, document method in JSON output.

7. **Progressed Moon sub-monthly precision** — Progressed Moon moves 12-14°/year, changes sign every 2.5 months, but yearly snapshots miss critical phase changes. Prevention: Offer `--progressed-moon-monthly` flag for 12 monthly snapshots per year, calculate progressed lunar return dates.

8. **Monolithic file becomes unmaintainable** — Current 1,070 LOC + ~700 new = 1,770 LOC, manageable but nearing threshold. Prevention: Don't refactor until transit mode works (avoid premature extraction bugs), refactor between Phase 2 and Phase 3 by extracting utilities (`date_validation.py`, `timezone.py`) and calculation modules (`natal.py`, `transits.py`, `progressions.py`).

## Implications for Roadmap

Based on research, suggested phase structure prioritizes core predictive functionality first (current transits, progressions, solar arc), then enhancements (timelines, monthly Moon precision), finally polish features (tri-wheel SVG, applying/separating indicators).

### Phase 1: Current Transit Snapshots
**Rationale:** Simplest predictive feature, establishes timezone handling and cross-chart aspect calculation patterns that all other features depend on, auto-loads with charts for immediate value.

**Delivers:** Current transit snapshot (single datetime calculation), transit-to-natal aspects with configurable orbs, transit house positions, retrograde status, `--transits {slug} --date YYYY-MM-DD` CLI mode.

**Addresses:** Table stakes features (current transits, transit-to-natal aspects, configurable orbs, house positions, retrograde status).

**Avoids:** Pitfall 1 (breaking natal charts) via isolation, Pitfall 2 (timezone confusion) via explicit timezone context tracking, Pitfall 4 (ephemeris limits) via date range validation.

**Implements:** `build_transit_json()`, `calculate_aspects_between_charts()`, load natal profile mechanism, timezone context tracking.

**Research needs:** Standard implementation using Kerykeion factories, skip deep research.

---

### Phase 2: Transit Timelines
**Rationale:** Extends Phase 1 to date ranges, tests performance optimization strategies before adding progression complexity, validates `find_transit_events()` architecture for future timeline features.

**Delivers:** Transit timeline with preset ranges (week/month/3mo/year), custom date ranges, event finding (exact aspect hits within orb threshold), `--transits {slug} --from ... --to ... --events` CLI mode.

**Uses:** Kerykeion's `TransitsTimeRangeFactory` for date range efficiency, `EphemerisDataFactory` for time-series planetary positions, `active_points` parameter to limit calculations.

**Avoids:** Pitfall 3 (date range performance) via 180-day limit, intelligent ephemeris use, skipping house calculations unless requested.

**Implements:** `find_transit_events()`, date range iteration with orb threshold detection, performance optimization patterns.

**Research needs:** Standard pattern, skip deep research but benchmark performance targets (1-year daily range <3 seconds).

---

### Phase 3: Secondary Progressions
**Rationale:** Adds internal psychological timing layer, progressed Moon monthly precision is high-value differentiator, establishes progression calculation pattern before solar arc (which is simpler).

**Delivers:** Secondary progressions for target date/age, progressed-to-natal aspects, progressed Moon monthly precision option, `--progressions {slug} --year YYYY` CLI mode.

**Uses:** Day-for-a-year formula (`birth_date + timedelta(days=age_in_years)`), existing `AstrologicalSubjectFactory` with progressed date at natal location, 1° orb standard for progressed-to-natal aspects.

**Avoids:** Pitfall 5 (retrograde station math) by using Kerykeion's progression calculations directly, Pitfall 7 (progressed Moon precision) via `--progressed-moon-monthly` flag.

**Implements:** `build_progression_json()`, day-for-a-year calculation, progressed-to-natal aspect detection (reuses `calculate_aspects_between_charts()`), monthly Moon option.

**Research needs:** Standard day-for-a-year technique, skip deep research but test with known birth dates that include planetary stations in first 80 days.

---

### Phase 4: Solar Arc Directions
**Rationale:** Simpler than progressions (arithmetic only, no ephemeris lookup per planet), completes core predictive trio, true arc method establishes accuracy standard.

**Delivers:** Solar arc directions for target year, solar arc-to-natal aspects with 0.5-1° orb, true arc method by default with optional mean arc, `--solar-arc {slug} --year YYYY` CLI mode.

**Uses:** `swisseph.calc_ut()` for progressed Sun position, arc arithmetic (`progressed_sun_longitude - natal_sun_longitude`), apply arc to all natal positions, 0.5-1° orb (tighter than progressions).

**Avoids:** Pitfall 6 (true vs mean arc confusion) via explicit method parameter and JSON documentation, default to true arc for accuracy.

**Implements:** `build_solar_arc_json()`, arc calculation, position offset arithmetic, solar arc-to-natal aspect detection.

**Research needs:** Standard technique, skip deep research.

---

### Phase 5: Interpretation Guide & Context Injection
**Rationale:** Transforms raw aspect data into actionable astrological context for Claude, completes skill integration, enables expert-level synthesis.

**Delivers:** Comprehensive transit/progression/solar arc interpretation guide (markdown format), dual guide injection (natal + transit), combined JSON output for natal + predictive data, `--load {slug} --now` mode (auto-load with current transits).

**Uses:** Existing natal guide pattern, extends with transit meanings (outer planets = long-term, inner = triggers), aspect orbs per calculation type, applying vs separating context, progression interpretation (inner development vs external events), solar arc timing (1° = 1 year).

**Addresses:** Table stakes feature (interpretation guide), competitive feature (auto-load transits with chart).

**Implements:** Transit guide creation, skill layer routing updates, context injection logic.

**Research needs:** Skip deep research, guide content based on established astrological interpretation patterns.

---

### Phase 6: Optional Snapshot Storage
**Rationale:** Enables audit trail for important transit/progression moments, optional feature doesn't complicate default workflow, completes storage architecture.

**Delivers:** `--save` flag for snapshot storage, filename conventions (`transits-YYYY-MM-DD.json`, `progressions-YYYY.json`, `solar-arc-YYYY.json`), optional snapshot listing.

**Uses:** Existing profile directory structure (`~/.natal-charts/{slug}/`), JSON serialization, date-based filenames.

**Addresses:** Competitive feature (fresh vs snapshot modes).

**Implements:** Snapshot save logic, filename generation, optional listing.

**Research needs:** Skip deep research, standard file I/O patterns.

---

### Phase Ordering Rationale

1. **Current transits first** establishes critical architectural patterns (timezone handling, cross-chart aspects, natal profile loading) that all subsequent phases depend on. Breaking natal chart functionality here is caught early before adding complexity.

2. **Transit timelines second** tests performance optimization strategies (date ranges, ephemeris efficiency) in the simpler transit context before progressions/solar arc add calculation complexity. Validates event-finding architecture for future timeline features.

3. **Progressions before solar arc** because progressions are more complex (retrograde station handling, monthly Moon precision, ephemeris lookups) and represent the harder test case. Solar arc is simpler arithmetic once progression patterns established.

4. **Interpretation guide after calculations work** avoids premature guide content that must be revised when calculation structure changes. Guide content informed by actual JSON output structure.

5. **Snapshot storage last** because it's optional polish that doesn't affect core functionality. Can be deferred if timeline slips.

**Dependency chain:** Phase 1 → Phase 2 (extends Phase 1 to ranges) → Phase 3 (uses Phase 1 aspect logic) → Phase 4 (uses Phase 1 aspect logic) → Phase 5 (integrates Phases 1-4 output) → Phase 6 (stores Phases 1-4 output)

### Research Flags

**Phases with standard patterns (skip research-phase):**
- **Phase 1 (Current transits):** Kerykeion `TransitsTimeRangeFactory` is well-documented, transit aspect calculation is established pattern
- **Phase 2 (Transit timelines):** Extension of Phase 1 using same factories, date iteration is standard
- **Phase 3 (Secondary progressions):** Day-for-a-year formula is well-documented, Kerykeion handles calculation
- **Phase 4 (Solar arc):** True arc calculation is simple arithmetic, well-documented in astrology references
- **Phase 5 (Interpretation guide):** Content synthesis from established astrological interpretation patterns
- **Phase 6 (Snapshot storage):** Standard file I/O, no domain-specific complexity

**No phases need deep research** — all techniques are well-documented in astrology software and Kerykeion provides the necessary APIs. Research-phase should be skipped for all phases to accelerate delivery.

**Testing focus instead:**
- Phase 1: Regression testing for natal charts, timezone validation with multiple contexts
- Phase 2: Performance benchmarking (1-year daily range <3 seconds), date range limit enforcement
- Phase 3: Retrograde station handling with known birth dates, monthly Moon precision verification
- Phase 4: True vs mean arc accuracy comparison, 40-year arc test cases

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Kerykeion 5.7.2 verified with local installation, official documentation confirms `TransitsTimeRangeFactory` and `EphemerisDataFactory` availability, pyswisseph bundled and accessible |
| Features | HIGH | Multiple authoritative astrology software sources (TimePassages, Astro-Seek, Astro Gold) show consistent feature expectations, table stakes vs differentiators clearly defined |
| Architecture | HIGH | Kerykeion API examples demonstrate transit chart creation, progression calculation via date offset is standard pattern, existing v1.0 monolithic architecture extends cleanly |
| Pitfalls | MEDIUM | Timezone handling complexity confirmed via Swiss Ephemeris documentation and Time Nomad accuracy guide, retrograde station issues documented in Astrology Podcast, performance concerns inferred from date range math but not empirically tested |

**Overall confidence:** HIGH

Research based on official Kerykeion documentation, verified local installation, authoritative astrology software analysis, and established astrological calculation methods. Primary uncertainty is performance optimization for date ranges (Pitfall 3) which requires empirical testing during Phase 2 implementation.

### Gaps to Address

**Gap 1: Kerykeion 5.7.2 progression API specifics**
- **Issue:** Documentation confirms `TransitsTimeRangeFactory` but progression-specific factory not explicitly documented for v5.7.2
- **Mitigation:** Manual progression calculation via day-for-a-year + `AstrologicalSubjectFactory` is fallback (well-documented pattern), test with local Kerykeion installation during Phase 3 planning to confirm API availability
- **When:** Phase 3 (Secondary progressions) planning stage

**Gap 2: Optimal date range limits for performance**
- **Issue:** 180-day limit inferred from calculation complexity, not empirically tested with Kerykeion's `TransitsTimeRangeFactory`
- **Mitigation:** Benchmark during Phase 2 implementation, adjust limit based on actual performance (target: 1-year daily range <3 seconds)
- **When:** Phase 2 (Transit timelines) execution

**Gap 3: Progressed angles calculation method**
- **Issue:** Multiple methods exist (Solar Arc vs True Secondary vs Mean Quotidian) for progressed Ascendant/MC, no single standard
- **Mitigation:** Use solar arc method for consistency with Phase 4, document limitation clearly in JSON output (`"progressed_angles_method": "solar_arc"`), defer alternative methods to v2 if users request
- **When:** Phase 3 (Secondary progressions) planning, document in interpretation guide Phase 5

## Sources

### Primary (HIGH confidence)
- **Kerykeion 5.7.2 PyPI** — Version confirmation, dependencies, factory architecture
- **Kerykeion GitHub Repository** — Transit support confirmation, API examples
- **Kerykeion Official Documentation** (`kerykeion.net/pydocs`) — `TransitsTimeRangeFactory`, `EphemerisDataFactory`, `PlanetaryReturnFactory` classes
- **Local Kerykeion 5.7.2 installation verification** — Confirmed factories available, tested import paths
- **Swiss Ephemeris Programming Interface** (`astro.com/swisseph/swephprg.htm`) — `calc_ut()` function documentation, timezone warnings
- **TimePassages, Astro-Seek, Astro Gold software** — Feature analysis, UI patterns, calculation methods

### Secondary (MEDIUM confidence)
- **Cafe Astrology (Secondary Progressions, Progressed Moon Aspects)** — Day-for-a-year formula validation, progressed Moon precision requirements
- **Astro-Seek calculators (Transit, Secondary Progressions, Solar Arc)** — JSON data format patterns, calculation method validation
- **Astrodienst Solar Arc article** — True vs mean arc comparison
- **The Astrology Podcast (How to Read an Ephemeris, Planetary Stations in Progressions)** — Ephemeris reliability ranges, retrograde station duration
- **Time Nomad accuracy guide** — Timezone conversion pitfalls in natal/transit calculations

### Tertiary (LOW confidence, technique validation only)
- **Astrotheme Solar Arc calculator** — Solar arc accuracy comparison (88.706° for 90 years)
- **My Sky Pie retrograde direction article** — Progressed planet retrograde motion explanation
- **Real Python refactoring guide** — Code organization patterns for monolithic file extraction

---
*Research completed: 2026-02-17*
*Ready for roadmap: Yes*
*Recommendation: Skip research-phase for all phases — use execution time for testing and validation instead*
